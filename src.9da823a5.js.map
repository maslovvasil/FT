{"version":3,"sources":["../node_modules/bootstrap.native/dist/bootstrap-native.esm.js","index.js"],"names":["EventRegistry","globalListener","e","that","type","forEach","elementsMap","element","listenersMap","listenerMap","listener","options","apply","once","removeListener","addListener","eventType","Map","oneEventMap","has","set","oneElementMap","get","size","addEventListener","savedOptions","eventOptions","undefined","delete","removeEventListener","Listener","on","off","registry","mouseclickEvent","transitionEndEvent","transitionDelay","transitionProperty","getElementStyle","property","computedStyle","getComputedStyle","includes","getPropertyValue","getElementTransitionDelay","propertyValue","delayValue","delayScale","duration","parseFloat","Number","isNaN","transitionDuration","getElementTransitionDuration","durationValue","durationScale","dispatchEvent","event","emulateTransitionEnd","handler","called","endEvent","Event","delay","transitionEndWrapper","target","setTimeout","isNode","some","x","nodeType","isWindow","object","constructor","name","isDocument","getDocument","node","ownerDocument","document","window","querySelector","selector","parent","lookUp","closest","getRootNode","host","ObjectAssign","obj","source","Object","assign","hasClass","classNAME","classList","contains","removeClass","remove","isHTMLElement","componentData","Data","component","instance","getAllFor","instanceMap","allForC","getInstance","isObject","OriginalEvent","EventType","config","OriginalCustomEvent","CustomEvent","cancelable","bubbles","fadeClass","showClass","dataBsDismiss","alertString","alertComponent","getAttribute","attribute","normalizeValue","value","ObjectKeys","keys","toLowerCase","normalizeOptions","defaultOps","inputOps","ns","data","dataset","normalOps","dataOps","k","key","replace","match","version","Version","BaseComponent","self","Error","prevInstance","dispose","defaults","length","prop","alertSelector","alertDismissSelector","getAlertInstance","alertInitCallback","Alert","closeAlertEvent","closedAlertEvent","alertTransitionEnd","toggleAlertHandler","add","action","dismiss","close","defaultPrevented","init","ariaPressed","setAttribute","addClass","activeClass","dataBsToggle","buttonString","buttonComponent","buttonSelector","getButtonInstance","buttonInitCallback","Button","toggleButtonHandler","toggle","isActive","preventDefault","mouseenterEvent","mouseleaveEvent","keydownEvent","keyArrowLeft","keyArrowRight","pointerdownEvent","pointermoveEvent","pointerupEvent","getBoundingClientRect","includeScale","width","height","top","right","bottom","left","scaleX","scaleY","offsetWidth","offsetHeight","Math","round","y","getDocumentElement","documentElement","isElementInScrollRange","clientHeight","isRTL","dir","querySelectorAll","getElementsByClassName","TimeCache","Timer","callback","keyTimers","clear","clearTimeout","reflow","passiveHandler","passive","dataBsTarget","carouselString","carouselComponent","dataBsParent","dataBsContainer","getTargetElement","targetAttr","doc","map","att","attValue","filter","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","pause","keyboard","touch","interval","getCarouselInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","carouselSlidEvent","carouselTransitionEndHandler","index","direction","slides","isAnimating","activeItem","getActiveIndex","orientation","directionClass","hidden","isPaused","cycle","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","indicator","newIndex","to","carouselControlsHandler","control","next","prev","carouselKeyHandler","code","test","tagName","RTL","arrowKeyNext","carouselPointerDownHandler","controls","indicators","el","isTouch","pageX","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","find","i","getSelection","toString","abs","activateCarouselIndicator","pageIndex","toggleCarouselHandlers","arrow","indexOf","id","idx","eventProperties","relatedTarget","from","itemClasses","slide","ariaExpanded","ObjectEntries","entries","setElementStyle","styles","style","setProperty","propObject","collapsingClass","collapseString","collapseComponent","collapseSelector","collapseToggleSelector","collapseDefaults","getCollapseInstance","collapseInitCallback","Collapse","showCollapseEvent","shownCollapseEvent","hideCollapseEvent","hiddenCollapseEvent","expandCollapse","triggers","scrollHeight","btn","collapseContent","toggleCollapseHandler","collapseClickHandler","trigger","hide","show","activeCollapse","activeCollapseInstance","focusEvent","keyupEvent","scrollEvent","resizeEvent","keyArrowUp","keyArrowDown","keyEscape","hasAttribute","focus","getWindow","defaultView","dropdownMenuClasses","dropdownComponent","dropdownMenuClass","isEmptyAnchor","parentAnchor","href","slice","dropdownString","dropupString","dropstartString","dropendString","dropdownSelector","getDropdownInstance","dropdownInitCallback","Dropdown","dropdownMenuEndClass","verticalClass","horizontalClass","menuFocusTags","dropdownDefaults","offset","display","showDropdownEvent","shownDropdownEvent","hideDropdownEvent","hiddenDropdownEvent","styleDropdown","menu","parentElement","menuEnd","p","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuStart","menuWidth","menuHeight","clientWidth","targetLeft","targetTop","targetWidth","targetHeight","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","posAjust","margin","join","getMenuItems","children","firstElementChild","toggleDropdownDismiss","open","dropdownDismissHandler","dropdownPreventScroll","dropdownKeyHandler","ev","dropdownLayoutHandler","toggleDropdownHandler","dropdownClickHandler","getCurrentOpenDropdown","currentParent","hasData","isForm","activeElement","menuItems","currentElement","currentInstance","ariaHidden","ariaModal","removeAttribute","getDocumentBody","body","modalString","modalComponent","isShadowRoot","getParentNode","nodeName","assignedSlot","parentNode","isTableElement","getElementContainer","getOffset","majorBlockTags","offsetParent","win","containers","shadowRoot","push","every","r","fixedTopClass","fixedBottomClass","stickyTopClass","positionStickyClass","getFixedItems","resetScrollbar","bd","paddingRight","overflow","fixedItems","fixed","marginRight","measureScrollbar","innerWidth","setScrollbar","bodyPad","parseInt","sbWidth","itemPadValue","itemMValue","createElement","param","attr","newElement","offcanvasString","backdropString","modalBackdropClass","offcanvasBackdropClass","modalActiveSelector","offcanvasActiveSelector","overlay","getCurrentOpen","toggleOverlayType","isModal","targetClass","appendOverlay","container","hasFade","append","showOverlay","hideOverlay","removeOverlay","isVisible","modalSelector","modalToggleSelector","modalDismissSelector","modalStaticClass","modalDefaults","backdrop","getModalInstance","modalInitCallback","Modal","showModalEvent","shownModalEvent","hideModalEvent","hiddenModalEvent","setModalScrollbar","scrollbarWidth","modalHeight","modalScrollHeight","modalOverflow","pad","padStyle","toggleModalDismiss","modalDismissHandler","update","modalKeyHandler","toggleModalHandler","modalClickHandler","afterModalHide","focusElement","afterModalShow","beforeModalShow","beforeModalHide","isStatic","modalDialog","selectedText","targetInsideDialog","staticTransitionEnd","bind","overlayDelay","currentOpen","offcanvasComponent","offcanvasSelector","offcanvasToggleSelector","offcanvasDismissSelector","offcanvasTogglingClass","offcanvasDefaults","scroll","getOffcanvasInstance","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","toggleOffcanvasEvents","offcanvasTriggerHandler","toggleOffCanvasDismiss","offcanvasKeyDismissHandler","offcanvasDismissHandler","beforeOffcanvasShow","visibility","showOffcanvasComplete","beforeOffcanvasHide","blur","hideOffcanvasComplete","offCanvasDismiss","selection","visibleTrigger","popoverString","popoverComponent","tooltipString","getTipTemplate","tipType","isTooltip","isMedia","s","getNodeScroll","isWin","scrollX","scrollLeft","scrollY","scrollTop","isScaledElement","getRectRelativeToOffsetParent","isParentAnElement","rect","offsets","offsetRect","clientLeft","clientTop","tipClassPositions","styleTip","tipClasses","tooltip","tipPositions","isPopover","tipWidth","tipHeight","htmlcw","htmlch","placement","parentLeft","parentRight","parentTop","parentCWidth","parentOWidth","parentPosition","fixedParent","staticParent","isSticky","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","horizontal","vertical","className","eX","eY","pageY","clientX","clientY","tooltipDefaults","template","title","customClass","sanitizeFn","animation","ariaDescribedBy","mousedownEvent","mousemoveEvent","focusinEvent","focusoutEvent","mousehoverEvent","touchstartEvent","elementUID","elementMapUID","elementIDMap","getUID","result","elID","elMap","elkey","isFunction","fn","userAgentData","uaDATA","navigator","userAgent","userAgentString","appleBrands","isApple","brands","brand","dataOriginalTitle","tooltipComponent","isNodeList","isString","str","isArray","arr","Array","setHtml","content","dirty","trim","tempDocument","DOMParser","parseFromString","childNodes","createTip","dismissible","btnClose","tipString","titleParts","contentParts","placementClass","tooltipTemplate","htmlMarkup","firstChild","cloneNode","bodyClass","tooltipHeader","tooltipBody","tempTitle","tempContent","tempBtn","isVisibleTip","tip","tooltipSelector","titleAttr","getTooltipInstance","tooltipInitCallback","Tooltip","removeTooltip","disposeTooltipComplete","toggleTooltipHandlers","toggleTooltipTitle","toggleTooltipAction","handleTouch","tooltipShownAction","shownTooltipEvent","tooltipHiddenAction","hiddenTooltipEvent","enabled","triggerOptions","split","elemIsMedia","tr","toggleTooltipOpenHandlers","parentModal","parentOffcanvas","scrollTarget","titleAtt","tipComponent","elem","idealContainer","outTimer","showTooltipEvent","hideTooltipEvent","enable","disable","toggleEnabled","popoverSelector","popoverDefaults","Popover","getPopoverInstance","popoverInitCallback","getElementsByTagName","scrollspyString","scrollspyComponent","scrollspySelector","scrollspyDefaults","getScrollSpyInstance","scrollspyInitCallback","ScrollSpy","activateScrollSpy","updateSpyTargets","itemsLength","links","scrollHEIGHT","getScrollHeight","targetItem","items","maxScroll","getOffsetHeight","link","charAt","offsetTop","innerHeight","item","activate","parents","parentItem","menuItem","parentLink","previousElementSibling","toggleSpyHandlers","refresh","newActiveItem","ariaSelected","tabString","tabComponent","tabSelector","getTabInstance","tabInitCallback","Tab","showTabEvent","shownTabEvent","hideTabEvent","hiddenTabEvent","tabPrivate","triggerTabEnd","tabContent","nav","triggerTabShow","nextContent","tab","currentHeight","nextHeight","triggerTabHide","getActiveTab","activeTabs","getParentDropdown","toggleTabHandler","tabClickHandler","firstTab","firstTabContent","activeDropdown","toggleTab","toastString","toastComponent","toastSelector","toastDismissSelector","toastToggleSelector","showingClass","hideClass","toastDefaults","autohide","getToastInstance","toastInitCallback","Toast","showToastEvent","shownToastEvent","hideToastEvent","hiddenToastEvent","showToastComplete","hideToastComplete","hideToast","showToast","toggleToastHandlers","interactiveToastHandler","toastClickHandler","completeDisposeToast","isShown","matches","componentsList","initComponentDataAPI","collection","removeComponentDataAPI","context","compData","initCallback","elemCollection","comp","removeDataAPI","BSN","EventListener","modal","console","log","PROMPT_DELAY"],"mappings":"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","file":"src.9da823a5.js","sourceRoot":"../src","sourcesContent":["/*!\n  * Native JavaScript for Bootstrap v4.2.0 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022  dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n/** @type {Record<string, any>} */\nconst EventRegistry = {};\n\n/**\n * The global event listener.\n *\n * @type {EventListener}\n * @this {EventTarget}\n */\nfunction globalListener(e) {\n  const that = this;\n  const { type } = e;\n\n  [...EventRegistry[type]].forEach((elementsMap) => {\n    const [element, listenersMap] = elementsMap;\n    /* istanbul ignore else */\n    if (element === that) {\n      [...listenersMap].forEach((listenerMap) => {\n        const [listener, options] = listenerMap;\n        listener.apply(element, [e]);\n\n        if (options && options.once) {\n          removeListener(element, type, listener, options);\n        }\n      });\n    }\n  });\n}\n\n/**\n * Register a new listener with its options and attach the `globalListener`\n * to the target if this is the first listener.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst addListener = (element, eventType, listener, options) => {\n  // get element listeners first\n  if (!EventRegistry[eventType]) {\n    EventRegistry[eventType] = new Map();\n  }\n  const oneEventMap = EventRegistry[eventType];\n\n  if (!oneEventMap.has(element)) {\n    oneEventMap.set(element, new Map());\n  }\n  const oneElementMap = oneEventMap.get(element);\n\n  // get listeners size\n  const { size } = oneElementMap;\n\n  // register listener with its options\n  oneElementMap.set(listener, options);\n\n  // add listener last\n  if (!size) {\n    element.addEventListener(eventType, globalListener, options);\n  }\n};\n\n/**\n * Remove a listener from registry and detach the `globalListener`\n * if no listeners are found in the registry.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst removeListener = (element, eventType, listener, options) => {\n  // get listener first\n  const oneEventMap = EventRegistry[eventType];\n  const oneElementMap = oneEventMap && oneEventMap.get(element);\n  const savedOptions = oneElementMap && oneElementMap.get(listener);\n\n  // also recover initial options\n  const { options: eventOptions } = savedOptions !== undefined\n    ? savedOptions\n    : { options };\n\n  // unsubscribe second, remove from registry\n  if (oneElementMap && oneElementMap.has(listener)) oneElementMap.delete(listener);\n  if (oneEventMap && (!oneElementMap || !oneElementMap.size)) oneEventMap.delete(element);\n  if (!oneEventMap || !oneEventMap.size) delete EventRegistry[eventType];\n\n  // remove listener last\n  /* istanbul ignore else */\n  if (!oneElementMap || !oneElementMap.size) {\n    element.removeEventListener(eventType, globalListener, eventOptions);\n  }\n};\n\n/**\n * Advanced event listener based on subscribe / publish pattern.\n * @see https://www.patterns.dev/posts/classic-design-patterns/#observerpatternjavascript\n * @see https://gist.github.com/shystruk/d16c0ee7ac7d194da9644e5d740c8338#file-subpub-js\n * @see https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8\n */\nconst Listener = {\n  on: addListener,\n  off: removeListener,\n  globalListener,\n  registry: EventRegistry,\n};\n\n/**\n * A global namespace for `click` event.\n * @type {string}\n */\nconst mouseclickEvent = 'click';\n\n/**\n * A global namespace for 'transitionend' string.\n * @type {string}\n */\nconst transitionEndEvent = 'transitionend';\n\n/**\n * A global namespace for 'transitionDelay' string.\n * @type {string}\n */\nconst transitionDelay = 'transitionDelay';\n\n/**\n * A global namespace for `transitionProperty` string for modern browsers.\n *\n * @type {string}\n */\nconst transitionProperty = 'transitionProperty';\n\n/**\n * Shortcut for `window.getComputedStyle(element).propertyName`\n * static method.\n *\n * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n * throws a `ReferenceError`.\n *\n * @param {HTMLElement} element target\n * @param {string} property the css property\n * @return {string} the css property value\n */\nfunction getElementStyle(element, property) {\n  const computedStyle = getComputedStyle(element);\n\n  // must use camelcase strings,\n  // or non-camelcase strings with `getPropertyValue`\n  return property.includes('--')\n    ? computedStyle.getPropertyValue(property)\n    : computedStyle[property];\n}\n\n/**\n * Utility to get the computed `transitionDelay`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDelay(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const delayValue = getElementStyle(element, transitionDelay);\n  const delayScale = delayValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(delayValue) * delayScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * A global namespace for 'transitionDuration' string.\n * @type {string}\n */\nconst transitionDuration = 'transitionDuration';\n\n/**\n * Utility to get the computed `transitionDuration`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDuration(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const durationValue = getElementStyle(element, transitionDuration);\n  const durationScale = durationValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(durationValue) * durationScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * Shortcut for the `Element.dispatchEvent(Event)` method.\n *\n * @param {HTMLElement} element is the target\n * @param {Event} event is the `Event` object\n */\nconst dispatchEvent = (element, event) => element.dispatchEvent(event);\n\n/**\n * Utility to make sure callbacks are consistently\n * called when transition ends.\n *\n * @param {HTMLElement} element target\n * @param {EventListener} handler `transitionend` callback\n */\nfunction emulateTransitionEnd(element, handler) {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent);\n  const duration = getElementTransitionDuration(element);\n  const delay = getElementTransitionDelay(element);\n\n  if (duration) {\n    /**\n     * Wrap the handler in on -> off callback\n     * @type {EventListener} e Event object\n     */\n    const transitionEndWrapper = (e) => {\n      /* istanbul ignore else */\n      if (e.target === element) {\n        handler.apply(element, [e]);\n        element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n        called = 1;\n      }\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper);\n    setTimeout(() => {\n      /* istanbul ignore next */\n      if (!called) dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else {\n    handler.apply(element, [endEvent]);\n  }\n}\n\n/**\n * Checks if an object is a `Node`.\n *\n * @param {any} node the target object\n * @returns {boolean} the query result\n */\nconst isNode = (element) => (element && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  .some((x) => +element.nodeType === x)) || false;\n\n/**\n * Check if a target object is `Window`.\n * => equivalent to `object instanceof Window`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isWindow = (object) => (object && object.constructor.name === 'Window') || false;\n\n/**\n * Checks if an object is a `Document`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isDocument = (object) => (object && object.nodeType === 9) || false;\n\n/**\n * Returns the `document` or the `#document` element.\n * @see https://github.com/floating-ui/floating-ui\n * @param {(Node | Window)=} node\n * @returns {Document}\n */\nfunction getDocument(node) {\n  // node instanceof Document\n  if (isDocument(node)) return node;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument;\n  // node instanceof Window\n  if (isWindow(node)) return node.document;\n  // node is undefined | NULL\n  return window.document;\n}\n\n/**\n * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n * or find one that matches a selector.\n *\n * @param {Node | string} selector the input selector or target element\n * @param {ParentNode=} parent optional node to look into\n * @return {HTMLElement?} the `HTMLElement` or `querySelector` result\n */\nfunction querySelector(selector, parent) {\n  if (isNode(selector)) {\n    return selector;\n  }\n  const lookUp = isNode(parent) ? parent : getDocument();\n\n  return lookUp.querySelector(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.closest` method which also works\n * with children of `ShadowRoot`. The order of the parameters\n * is intentional since they're both required.\n *\n * @see https://stackoverflow.com/q/54520554/803358\n *\n * @param {HTMLElement} element Element to look into\n * @param {string} selector the selector name\n * @return {HTMLElement?} the query result\n */\nfunction closest(element, selector) {\n  return element ? (element.closest(selector)\n    // break out of `ShadowRoot`\n    || closest(element.getRootNode().host, selector)) : null;\n}\n\n/**\n * Shortcut for `Object.assign()` static method.\n * @param  {Record<string, any>} obj a target object\n * @param  {Record<string, any>} source a source object\n */\nconst ObjectAssign = (obj, source) => Object.assign(obj, source);\n\n/**\n * Check class in `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to check\n * @returns {boolean}\n */\nfunction hasClass(element, classNAME) {\n  return element.classList.contains(classNAME);\n}\n\n/**\n * Remove class from `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to remove\n * @returns {void}\n */\nfunction removeClass(element, classNAME) {\n  element.classList.remove(classNAME);\n}\n\n/**\n * Checks if an element is an `HTMLElement`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} element the target object\n * @returns {boolean} the query result\n */\nconst isHTMLElement = (element) => (element && element.nodeType === 1) || false;\n\n/** @type {Map<string, Map<HTMLElement, Record<string, any>>>} */\nconst componentData = new Map();\n/**\n * An interface for web components background data.\n * @see https://github.com/thednp/bootstrap.native/blob/master/src/components/base-component.js\n */\nconst Data = {\n  /**\n   * Sets web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @param {Record<string, any>} instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (!componentData.has(component)) {\n      componentData.set(component, new Map());\n    }\n\n    const instanceMap = componentData.get(component);\n    // not undefined, but defined right above\n    instanceMap.set(element, instance);\n  },\n\n  /**\n   * Returns all instances for specified component.\n   * @param {string} component the component's name or a unique key\n   * @returns {Map<HTMLElement, Record<string, any>>?} all the component instances\n   */\n  getAllFor: (component) => {\n    const instanceMap = componentData.get(component);\n\n    return instanceMap || null;\n  },\n\n  /**\n   * Returns the instance associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @returns {Record<string, any>?} the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const allForC = Data.getAllFor(component);\n    const instance = element && allForC && allForC.get(element);\n\n    return instance || null;\n  },\n\n  /**\n   * Removes web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = componentData.get(component);\n    if (!instanceMap || !isHTMLElement(element)) return;\n\n    instanceMap.delete(element);\n\n    /* istanbul ignore else */\n    if (instanceMap.size === 0) {\n      componentData.delete(component);\n    }\n  },\n};\n\n/**\n * An alias for `Data.get()`.\n * @type {SHORTY.getInstance<any>}\n */\nconst getInstance = (target, component) => Data.get(target, component);\n\n/**\n * Checks if an object is an `Object`.\n *\n * @param {any} obj the target object\n * @returns {boolean} the query result\n */\nconst isObject = (obj) => (typeof obj === 'object') || false;\n\n/**\n * Returns a namespaced `CustomEvent` specific to each component.\n * @param {string} EventType Event.type\n * @param {Record<string, any>=} config Event.options | Event.properties\n * @returns {SHORTY.OriginalEvent} a new namespaced event\n */\nfunction OriginalEvent(EventType, config) {\n  const OriginalCustomEvent = new CustomEvent(EventType, {\n    cancelable: true, bubbles: true,\n  });\n\n  /* istanbul ignore else */\n  if (isObject(config)) {\n    ObjectAssign(OriginalCustomEvent, config);\n  }\n  return OriginalCustomEvent;\n}\n\n/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\n\n/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\n\n/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\n\n/** @type {string} */\nconst alertString = 'alert';\n\n/** @type {string} */\nconst alertComponent = 'Alert';\n\n/**\n * Shortcut for `HTMLElement.getAttribute()` method.\n * @param {HTMLElement} element target element\n * @param {string} attribute attribute name\n * @returns {string?} attribute value\n */\nconst getAttribute = (element, attribute) => element.getAttribute(attribute);\n\n/**\n * The raw value or a given component option.\n *\n * @typedef {string | HTMLElement | Function | number | boolean | null} niceValue\n */\n\n/**\n * Utility to normalize component options\n *\n * @param {any} value the input value\n * @return {niceValue} the normalized value\n */\nfunction normalizeValue(value) {\n  if (['true', true].includes(value)) { // boolean\n  // if ('true' === value) { // boolean\n    return true;\n  }\n\n  if (['false', false].includes(value)) { // boolean\n  // if ('false' === value) { // boolean\n    return false;\n  }\n\n  if (value === '' || value === 'null') { // null\n    return null;\n  }\n\n  if (value !== '' && !Number.isNaN(+value)) { // number\n    return +value;\n  }\n\n  // string / function / HTMLElement / object\n  return value;\n}\n\n/**\n * Shortcut for `Object.keys()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {string[]}\n */\nconst ObjectKeys = (obj) => Object.keys(obj);\n\n/**\n * Shortcut for `String.toLowerCase()`.\n *\n * @param {string} source input string\n * @returns {string} lowercase output string\n */\nconst toLowerCase = (source) => source.toLowerCase();\n\n/**\n * Utility to normalize component options.\n *\n * @param {HTMLElement} element target\n * @param {Record<string, any>} defaultOps component default options\n * @param {Record<string, any>} inputOps component instance options\n * @param {string=} ns component namespace\n * @return {Record<string, any>} normalized component options object\n */\nfunction normalizeOptions(element, defaultOps, inputOps, ns) {\n  const data = { ...element.dataset };\n  /** @type {Record<string, any>} */\n  const normalOps = {};\n  /** @type {Record<string, any>} */\n  const dataOps = {};\n  const title = 'title';\n\n  ObjectKeys(data).forEach((k) => {\n    const key = ns && k.includes(ns)\n      ? k.replace(ns, '').replace(/[A-Z]/, (match) => toLowerCase(match))\n      : k;\n\n    dataOps[key] = normalizeValue(data[k]);\n  });\n\n  ObjectKeys(inputOps).forEach((k) => {\n    inputOps[k] = normalizeValue(inputOps[k]);\n  });\n\n  ObjectKeys(defaultOps).forEach((k) => {\n    /* istanbul ignore else */\n    if (k in inputOps) {\n      normalOps[k] = inputOps[k];\n    } else if (k in dataOps) {\n      normalOps[k] = dataOps[k];\n    } else {\n      normalOps[k] = k === title\n        ? getAttribute(element, title)\n        : defaultOps[k];\n    }\n  });\n\n  return normalOps;\n}\n\nvar version = \"4.2.0\";\n\nconst Version = version;\n\n/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\n\n/** Returns a new `BaseComponent` instance. */\nclass BaseComponent {\n  /**\n   * @param {HTMLElement | string} target `Element` or selector string\n   * @param {BSN.ComponentOptions=} config component instance options\n   */\n  constructor(target, config) {\n    const self = this;\n    const element = querySelector(target);\n\n    if (!element) {\n      throw Error(`${self.name} Error: \"${target}\" is not a valid selector.`);\n    }\n\n    /** @static @type {BSN.ComponentOptions} */\n    self.options = {};\n\n    const prevInstance = Data.get(element, self.name);\n    if (prevInstance) prevInstance.dispose();\n\n    /** @type {HTMLElement} */\n    self.element = element;\n\n    /* istanbul ignore else */\n    if (self.defaults && ObjectKeys(self.defaults).length) {\n      self.options = normalizeOptions(element, self.defaults, (config || {}), 'bs');\n    }\n\n    Data.set(element, self.name, self);\n  }\n\n  /* eslint-disable */\n  /* istanbul ignore next */\n  /** @static */\n  get version() { return Version; }\n\n  /* eslint-enable */\n  /* istanbul ignore next */\n  /** @static */\n  get name() { return this.constructor.name; }\n\n  /* istanbul ignore next */\n  /** @static */\n  get defaults() { return this.constructor.defaults; }\n\n  /**\n   * Removes component from target element;\n   */\n  dispose() {\n    const self = this;\n    Data.remove(self.element, self.name);\n    ObjectKeys(self).forEach((prop) => { self[prop] = null; });\n  }\n}\n\n/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Alert>}\n */\nconst getAlertInstance = (element) => getInstance(element, alertComponent);\n\n/**\n* An `Alert` initialization callback.\n* @type {BSN.InitCallback<Alert>}\n*/\nconst alertInitCallback = (element) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = OriginalEvent(`close.bs.${alertString}`);\nconst closedAlertEvent = OriginalEvent(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n * @param {Alert} self target Alert instance\n */\nfunction alertTransitionEnd(self) {\n  const { element } = self;\n  toggleAlertHandler(self);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  self.dispose();\n  element.remove();\n}\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n * @param {Alert} self the target alert instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleAlertHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { dismiss } = self;\n  /* istanbul ignore else */\n  if (dismiss) action(dismiss, mouseclickEvent, self.close);\n}\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nclass Alert extends BaseComponent {\n  /** @param {HTMLElement | string} target element or selector */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // the dismiss button\n    /** @static @type {HTMLElement?} */\n    self.dismiss = querySelector(alertDismissSelector, element);\n\n    // add event listener\n    toggleAlertHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return alertComponent; }\n  /* eslint-enable */\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   *\n   * @param {Event=} e most likely the `click` event\n   * @this {Alert} the `Alert` instance or `EventTarget`\n   */\n  close(e) {\n    const self = e ? getAlertInstance(closest(this, alertSelector)) : this;\n    const { element } = self;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n      if (closeAlertEvent.defaultPrevented) return;\n\n      removeClass(element, showClass);\n\n      if (hasClass(element, fadeClass)) {\n        emulateTransitionEnd(element, () => alertTransitionEnd(self));\n      } else alertTransitionEnd(self);\n    }\n  }\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Alert, {\n  selector: alertSelector,\n  init: alertInitCallback,\n  getInstance: getAlertInstance,\n});\n\n/**\n * A global namespace for aria-pressed.\n * @type {string}\n */\nconst ariaPressed = 'aria-pressed';\n\n/**\n * Shortcut for `HTMLElement.setAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @param  {string} value attribute value\n * @returns {void}\n */\nconst setAttribute = (element, attribute, value) => element.setAttribute(attribute, value);\n\n/**\n * Add class to `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to add\n * @returns {void}\n */\nfunction addClass(element, classNAME) {\n  element.classList.add(classNAME);\n}\n\n/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\n\n/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\n\n/** @type {string} */\nconst buttonString = 'button';\n\n/** @type {string} */\nconst buttonComponent = 'Button';\n\n/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Button>}\n */\nconst getButtonInstance = (element) => getInstance(element, buttonComponent);\n\n/**\n * A `Button` initialization callback.\n * @type {BSN.InitCallback<Button>}\n */\nconst buttonInitCallback = (element) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n * @param {Button} self the `Button` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleButtonHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n}\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nclass Button extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually a `.btn` element\n   */\n  constructor(target) {\n    super(target);\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // set initial state\n    /** @type {boolean} */\n    self.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, `${!!self.isActive}`);\n\n    // add event listener\n    toggleButtonHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return buttonComponent; }\n  /* eslint-enable */\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   * @param {MouseEvent} e usually `click` Event object\n   */\n  toggle(e) {\n    if (e) e.preventDefault();\n    const self = e ? getButtonInstance(this) : this;\n    if (!self.element) return;\n    const { element, isActive } = self;\n\n    if (hasClass(element, 'disabled')) return;\n\n    const action = isActive ? removeClass : addClass;\n    action(element, activeClass);\n    setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n    self.isActive = hasClass(element, activeClass);\n  }\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Button, {\n  selector: buttonSelector,\n  init: buttonInitCallback,\n  getInstance: getButtonInstance,\n});\n\n/**\n * A global namespace for `mouseenter` event.\n * @type {string}\n */\nconst mouseenterEvent = 'mouseenter';\n\n/**\n * A global namespace for `mouseleave` event.\n * @type {string}\n */\nconst mouseleaveEvent = 'mouseleave';\n\n/**\n * A global namespace for `keydown` event.\n * @type {string}\n */\nconst keydownEvent = 'keydown';\n\n/**\n * A global namespace for `ArrowLeft` key.\n * @type {string} e.which = 37 equivalent\n */\nconst keyArrowLeft = 'ArrowLeft';\n\n/**\n * A global namespace for `ArrowRight` key.\n * @type {string} e.which = 39 equivalent\n */\nconst keyArrowRight = 'ArrowRight';\n\n/**\n * A global namespace for `pointerdown` event.\n * @type {string}\n */\nconst pointerdownEvent = 'pointerdown';\n\n/**\n * A global namespace for `pointermove` event.\n * @type {string}\n */\nconst pointermoveEvent = 'pointermove';\n\n/**\n * A global namespace for `pointerup` event.\n * @type {string}\n */\nconst pointerupEvent = 'pointerup';\n\n/**\n * Returns the bounding client rect of a target `HTMLElement`.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element event.target\n * @param {boolean=} includeScale when *true*, the target scale is also computed\n * @returns {SHORTY.BoundingClientRect} the bounding client rect object\n */\nfunction getBoundingClientRect(element, includeScale) {\n  const {\n    width, height, top, right, bottom, left,\n  } = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth, offsetHeight } = element;\n    scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth\n      : /* istanbul ignore next */1;\n    scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight\n      : /* istanbul ignore next */1;\n  }\n\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY,\n  };\n}\n\n/**\n * Returns the `document.documentElement` or the `<html>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLHtmlElement}\n */\nfunction getDocumentElement(node) {\n  return getDocument(node).documentElement;\n}\n\n/**\n * Utility to determine if an `HTMLElement`\n * is partially visible in viewport.\n *\n * @param {HTMLElement} element target\n * @return {boolean} the query result\n */\nconst isElementInScrollRange = (element) => {\n  if (!element || !isNode(element)) return false;\n\n  const { top, bottom } = getBoundingClientRect(element);\n  const { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n};\n\n/**\n * Checks if a page is Right To Left.\n * @param {HTMLElement=} node the target\n * @returns {boolean} the query result\n */\nconst isRTL = (node) => getDocumentElement(node).dir === 'rtl';\n\n/**\n * A shortcut for `(document|Element).querySelectorAll`.\n *\n * @param {string} selector the input selector\n * @param {ParentNode=} parent optional node to look into\n * @return {NodeListOf<HTMLElement>} the query result\n */\nfunction querySelectorAll(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.querySelectorAll(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.getElementsByClassName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByClassName`.\n *\n * @param {string} selector the class name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByClassName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByClassName(selector);\n}\n\n/** @type {Map<HTMLElement, any>} */\nconst TimeCache = new Map();\n/**\n * An interface for one or more `TimerHandler`s per `Element`.\n * @see https://github.com/thednp/navbar.js/\n */\nconst Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   * @param {HTMLElement} element target element\n   * @param {ReturnType<TimerHandler>} callback the callback\n   * @param {number} delay the execution delay\n   * @param {string=} key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (key && key.length) {\n      /* istanbul ignore else */\n      if (!TimeCache.has(element)) {\n        TimeCache.set(element, new Map());\n      }\n      const keyTimers = TimeCache.get(element);\n      keyTimers.set(key, setTimeout(callback, delay));\n    } else {\n      TimeCache.set(element, setTimeout(callback, delay));\n    }\n  },\n\n  /**\n   * Returns the timer associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique\n   * @returns {number?} the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n\n    if (key && key.length && keyTimers && keyTimers.get) {\n      return keyTimers.get(key) || /* istanbul ignore next */null;\n    }\n    return keyTimers || null;\n  },\n\n  /**\n   * Clears the element's timer.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n\n    if (key && key.length) {\n      const keyTimers = TimeCache.get(element);\n      /* istanbul ignore else */\n      if (keyTimers && keyTimers.get) {\n        clearTimeout(keyTimers.get(key));\n        keyTimers.delete(key);\n        /* istanbul ignore else */\n        if (keyTimers.size === 0) {\n          TimeCache.delete(element);\n        }\n      }\n    } else {\n      clearTimeout(TimeCache.get(element));\n      TimeCache.delete(element);\n    }\n  },\n};\n\n/**\n * Utility to force re-paint of an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n * @return {number} the `Element.offsetHeight` value\n */\nconst reflow = (element) => element.offsetHeight;\n\n/**\n * A global namespace for most scroll event listeners.\n * @type {Partial<AddEventListenerOptions>}\n */\nconst passiveHandler = { passive: true };\n\n/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\n\n/** @type {string} */\nconst carouselString = 'carousel';\n\n/** @type {string} */\nconst carouselComponent = 'Carousel';\n\n/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\n\n/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param {HTMLElement} element the target element\n * @returns {HTMLElement?} the query result\n */\nfunction getTargetElement(element) {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr.map((att) => {\n    const attValue = getAttribute(element, att);\n    if (attValue) {\n      return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n    }\n    return null;\n  }).filter((x) => x)[0];\n}\n\n/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Carousel>}\n */\nconst getCarouselInstance = (element) => getInstance(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n * @type {BSN.InitCallback<Carousel>}\n */\nconst carouselInitCallback = (element) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = OriginalEvent(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = OriginalEvent(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n * @param {Carousel} self the `Carousel` instance\n */\nfunction carouselTransitionEndHandler(self) {\n  const {\n    index, direction, element, slides, options,\n  } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval\n      && !self.isPaused) {\n      self.cycle();\n    }\n  }\n}\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselPauseHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(element, pausedClass)) {\n    addClass(element, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselResumeHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(element, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselIndicatorHandler(e) {\n  e.preventDefault();\n  const indicator = this;\n  const element = closest(indicator, carouselSelector) || getTargetElement(indicator);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +getAttribute(indicator, dataBsSlideTo);\n\n  if (indicator && !hasClass(indicator, activeClass) // event target is not active\n    && !Number.isNaN(newIndex)) { // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselControlsHandler(e) {\n  e.preventDefault();\n  const control = this;\n  const element = closest(control, carouselSelector) || getTargetElement(control);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(control, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction carouselKeyHandler({ code, target }) {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)]\n    .filter((x) => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.tagName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n}\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e the `Event` object\n */\nfunction carouselPointerDownHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(element);\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some((el) => (el === target || el.contains(target)))) {\n    return;\n  }\n\n  if (!self || self.isAnimating || self.isTouch) { return; }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (element.contains(target)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e\n */\nfunction carouselPointerMoveHandler(e) {\n  // const self = getCarouselInstance(this);\n\n  // if (!self || !self.isTouch) { return; }\n\n  currentX = e.pageX;\n}\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n\n * @param {PointerEvent} e\n */\nfunction carouselPointerUpHandler(e) {\n  const { target } = e;\n  const doc = getDocument(target);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c)).find((i) => i.isTouch);\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) { return; }\n\n  const { element, index } = self;\n  const RTL = isRTL(target);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection().toString().length) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0; currentX = 0; endX = 0;\n}\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {number} pageIndex the index of the new active indicator\n */\nfunction activateCarouselIndicator(self, pageIndex) {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n}\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselTouchHandlers(self, add) {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n}\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselHandlers(self, add) {\n  const {\n    element, options, slides, controls, indicators,\n  } = self;\n  const {\n    touch, pause, interval, keyboard,\n  } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach((arrow) => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach((indicator) => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler);\n}\n\n/**\n * Returns the index of the current active item.\n * @param {Carousel} self the `Carousel` instance\n * @returns {number} the query result\n */\nfunction getActiveIndex(self) {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return [...slides].indexOf(activeItem);\n}\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nclass Carousel extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target mostly a `.carousel` element\n   * @param {BSN.Options.Carousel=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    // initialization element\n    const { element } = self;\n\n    // additional properties\n    /** @type {string} */\n    self.direction = isRTL(element) ? 'right' : 'left';\n    /** @type {number} */\n    self.index = 0;\n    /** @type {boolean} */\n    self.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    self.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = self;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) { return; }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    self.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    /** @type {HTMLElement?} */\n    self.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    /** @type {HTMLElement[]} */\n    self.indicators = [\n      ...(self.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, self.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = self;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    self.options.interval = options.interval === true\n      ? carouselDefaults.interval\n      : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(self) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (self.indicators.length) activateCarouselIndicator(self, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(self, true);\n\n    // start to cycle if interval is set\n    if (options.interval) self.cycle();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return carouselComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return carouselDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Check if instance is paused.\n   * @returns {boolean}\n  */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   * @returns {boolean}\n  */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const self = this;\n    const {\n      element, options, isPaused, index,\n    } = self;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(element, () => {\n      // it's very important to check self.element\n      // where instance might have been disposed\n      /* istanbul ignore else */\n      if (self.element && !self.isPaused && !self.isTouch\n        && isElementInScrollRange(element)) {\n        self.to(index + 1);\n      }\n    }, options.interval, carouselString);\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const self = this;\n    const { element, options } = self;\n    /* istanbul ignore else */\n    if (!self.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(element, () => {}, 1, pausedClass);\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index + 1); }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index - 1); }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   * @param {number} idx the index of the item to jump to\n   */\n  to(idx) {\n    const self = this;\n    const {\n      element, slides, options,\n    } = self;\n    const activeItem = getActiveIndex(self);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (self.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n      self.direction = RTL ? 'right' : 'left'; // next\n    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n      self.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = self;\n\n    // find the right next index\n    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    self.index = next;\n    activateCarouselIndicator(self, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(element, () => {\n        addClass(slides[next], `${carouselItem}-${orientation}`);\n        reflow(slides[next]);\n        addClass(slides[next], `${carouselItem}-${directionClass}`);\n        addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n        emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));\n      }, 0, dataBsSlide);\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(element, () => {\n        Timer.clear(element, dataBsSlide);\n        // check for element, might have been disposed\n        /* istanbul ignore else */\n        if (element && options.interval && !self.isPaused) {\n          self.cycle();\n        }\n\n        dispatchEvent(element, carouselSlidEvent);\n      }, 0, dataBsSlide);\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const self = this;\n    const { slides } = self;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);\n      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Carousel, {\n  selector: carouselSelector,\n  init: carouselInitCallback,\n  getInstance: getCarouselInstance,\n});\n\n/**\n * A global namespace for aria-expanded.\n * @type {string}\n */\nconst ariaExpanded = 'aria-expanded';\n\n/**\n * Shortcut for `Object.entries()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {[string, any][]}\n */\nconst ObjectEntries = (obj) => Object.entries(obj);\n\n/**\n * Shortcut for multiple uses of `HTMLElement.style.propertyName` method.\n * @param  {HTMLElement} element target element\n * @param  {Partial<CSSStyleDeclaration>} styles attribute value\n */\nconst setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (key.includes('--')) {\n      element.style.setProperty(key, value);\n    } else {\n      const propObject = {}; propObject[key] = value;\n      ObjectAssign(element.style, propObject);\n    }\n  });\n};\n\n/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\n\n/** @type {string} */\nconst collapseString = 'collapse';\n\n/** @type {string} */\nconst collapseComponent = 'Collapse';\n\n/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Collapse>}\n */\nconst getCollapseInstance = (element) => getInstance(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n * @type {BSN.InitCallback<Collapse>}\n */\nconst collapseInitCallback = (element) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = OriginalEvent(`show.bs.${collapseString}`);\nconst shownCollapseEvent = OriginalEvent(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = OriginalEvent(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = OriginalEvent(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction expandCollapse(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (showCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  addClass(element, collapsingClass);\n  removeClass(element, collapseString);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'true'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n    addClass(element, showClass);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, shownCollapseEvent);\n  });\n}\n\n/**\n * Collapse the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction collapseContent(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (hideCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  removeClass(element, collapseString);\n  removeClass(element, showClass);\n  addClass(element, collapsingClass);\n\n  reflow(element);\n  setElementStyle(element, { height: '0px' });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    /* istanbul ignore else */\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'false'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, hiddenCollapseEvent);\n  });\n}\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n * @param {Collapse} self the `Collapse` instance\n * @param {boolean=} add when `true`, the event listener is added\n */\nfunction toggleCollapseHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, collapseClickHandler));\n  }\n}\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n * @param {MouseEvent} e the `Event` object\n */\nfunction collapseClickHandler(e) {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nclass Collapse extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target and `Element` that matches the selector\n   * @param {BSN.Options.Collapse=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element, options } = self;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(collapseToggleSelector, doc)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // set parent accordion\n    /** @type {HTMLElement?} */\n    self.parent = querySelector(options.parent, doc)\n      || getTargetElement(element) || null;\n\n    // add event listeners\n    toggleCollapseHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return collapseComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return collapseDefaults; }\n  /* eslint-enable */\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    const self = this;\n    if (!hasClass(self.element, showClass)) self.show();\n    else self.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const self = this;\n    const { triggers, element } = self;\n    if (Timer.get(element)) return;\n\n    collapseContent(self);\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const self = this;\n    const {\n      element, parent, triggers,\n    } = self;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)]\n        .find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(self);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    const self = this;\n    toggleCollapseHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Collapse, {\n  selector: collapseSelector,\n  init: collapseInitCallback,\n  getInstance: getCollapseInstance,\n});\n\n/**\n * A global namespace for `focus` event.\n * @type {string}\n */\nconst focusEvent = 'focus';\n\n/**\n * A global namespace for `keyup` event.\n * @type {string}\n */\nconst keyupEvent = 'keyup';\n\n/**\n * A global namespace for `scroll` event.\n * @type {string}\n */\nconst scrollEvent = 'scroll';\n\n/**\n * A global namespace for `resize` event.\n * @type {string}\n */\nconst resizeEvent = 'resize';\n\n/**\n * A global namespace for `ArrowUp` key.\n * @type {string} e.which = 38 equivalent\n */\nconst keyArrowUp = 'ArrowUp';\n\n/**\n * A global namespace for `ArrowDown` key.\n * @type {string} e.which = 40 equivalent\n */\nconst keyArrowDown = 'ArrowDown';\n\n/**\n * A global namespace for `Escape` key.\n * @type {string} e.which = 27 equivalent\n */\nconst keyEscape = 'Escape';\n\n/**\n * Shortcut for `HTMLElement.hasAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {boolean} the query result\n */\nconst hasAttribute = (element, attribute) => element.hasAttribute(attribute);\n\n/**\n * Utility to focus an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n */\nconst focus = (element) => element.focus();\n\n/**\n * Returns the `Window` object of a target node.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {(Node | Window)=} node target node\n * @returns {Window} the `Window` object\n */\nfunction getWindow(node) {\n  // node is undefined | NULL\n  if (!node) return window;\n  // node instanceof Document\n  if (isDocument(node)) return node.defaultView;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument.defaultView;\n  // node is instanceof Window\n  return node;\n}\n\n/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n\n/** @type {string} */\nconst dropdownComponent = 'Dropdown';\n\n/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param {Node} element the target element\n * @returns {boolean} the query result\n */\nfunction isEmptyAnchor(element) {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return isHTMLElement(element)\n    // anchor href starts with #\n    && ((hasAttribute(element, 'href') && element.href.slice(-1) === '#')\n    // OR a child of an anchor with href starts with #\n    || (parentAnchor && hasAttribute(parentAnchor, 'href')\n    && parentAnchor.href.slice(-1) === '#'));\n}\n\n/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [\n  dropdownString,\n  dropupString,\n  dropstartString,\n  dropendString,\n] = dropdownMenuClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Dropdown>}\n */\nconst getDropdownInstance = (element) => getInstance(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n * @type {BSN.InitCallback<Dropdown>}\n */\nconst dropdownInitCallback = (element) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = OriginalEvent(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = OriginalEvent(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = OriginalEvent(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = OriginalEvent(`hidden.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction styleDropdown(self) {\n  const {\n    element, menu, parentElement, options,\n  } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore next: this test requires a navbar */\n  if (getElementStyle(menu, 'position') === 'static') return;\n\n  const RTL = isRTL(element);\n  // const menuStart = hasClass(menu, dropdownMenuStartClass);\n  const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n  // reset menu offset and position\n  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n  resetProps.forEach((p) => { menu.style[p] = ''; });\n\n  // set initial position class\n  // take into account .btn-group parent as .dropdown\n  // this requires navbar/btn-group/input-group\n  let positionClass = dropdownMenuClasses.find((c) => hasClass(parentElement, c))\n    || /* istanbul ignore next: fallback position */ dropdownString;\n\n  /** @type {Record<string, Record<string, any>>} */\n  let dropdownMargin = {\n    dropdown: [offset, 0, 0],\n    dropup: [0, 0, offset],\n    dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n    dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n  };\n\n  /** @type {Record<string, Record<string, any>>} */\n  const dropdownPosition = {\n    dropdown: { top: '100%' },\n    dropup: { top: 'auto', bottom: '100%' },\n    dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n    dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n    menuStart: RTL ? { right: 0, left: 'auto' } : { right: 'auto', left: 0 },\n    menuEnd: RTL ? { right: 'auto', left: 0 } : { right: 0, left: 'auto' },\n  };\n\n  const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n  const { clientWidth, clientHeight } = getDocumentElement(element);\n  const {\n    left: targetLeft, top: targetTop,\n    width: targetWidth, height: targetHeight,\n  } = getBoundingClientRect(element);\n\n  // dropstart | dropend\n  const leftFullExceed = targetLeft - menuWidth - offset < 0;\n  // dropend\n  const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n  // dropstart | dropend\n  const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n  // dropdown\n  const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n  // dropup\n  const topExceed = targetTop - menuHeight - offset < 0;\n  // dropdown / dropup\n  const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd))\n    && targetLeft + targetWidth - menuWidth < 0;\n  const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd))\n    && targetLeft + menuWidth >= clientWidth;\n\n  // recompute position\n  // handle RTL as well\n  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropendString;\n  }\n  if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropstartString;\n  }\n  if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n    positionClass = dropupString;\n  }\n\n  // override position for horizontal classes\n  if (horizontalClass.includes(positionClass) && bottomExceed) {\n    ObjectAssign(dropdownPosition[positionClass], {\n      top: 'auto', bottom: 0,\n    });\n  }\n\n  // override position for vertical classes\n  if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n    // don't realign when menu is wider than window\n    // in both RTL and non-RTL readability is KING\n    let posAjust;\n    if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n    if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n    if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n  }\n\n  dropdownMargin = dropdownMargin[positionClass];\n  setElementStyle(menu, {\n    ...dropdownPosition[positionClass],\n    margin: `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`,\n  });\n\n  // override dropdown-menu-start | dropdown-menu-end\n  if (verticalClass.includes(positionClass) && menuEnd) {\n    /* istanbul ignore else */\n    if (menuEnd) {\n      const endAdjust = (!RTL && leftExceed) || (RTL && rightExceed)\n        ? 'menuStart' : /* istanbul ignore next */'menuEnd';\n      setElementStyle(menu, dropdownPosition[endAdjust]);\n    }\n  }\n}\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n * @param {HTMLElement} menu\n * @returns {HTMLElement[]}\n */\nfunction getMenuItems(menu) {\n  return [...menu.children].map((c) => {\n    if (c && menuFocusTags.includes(c.tagName)) return c;\n    const { firstElementChild } = c;\n    if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n      return firstElementChild;\n    }\n    return null;\n  }).filter((c) => c);\n}\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction toggleDropdownDismiss(self) {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param {Dropdown} self the `Dropdown` instance\n * @param {boolean=} add when `true`, it will add the event listener\n */\nfunction toggleDropdownHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler);\n}\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param {(Node | Window)=} element target\n * @returns {HTMLElement?} the query result\n */\nfunction getCurrentOpenDropdown(element) {\n  const currentParent = [...dropdownMenuClasses, 'btn-group', 'input-group']\n    .map((c) => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...currentParent[0].children]\n      .find((x) => hasAttribute(x, dataBsToggle));\n  }\n  return null;\n}\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param {MouseEvent} e event object\n * @this {Document}\n */\nfunction dropdownDismissHandler(e) {\n  const { target, type } = e;\n\n  /* istanbul ignore next: impossible to satisfy */\n  if (!target || !target.closest) return; // some weird FF bug #409\n\n  const element = getCurrentOpenDropdown(target);\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore next */\n  if (!self) return;\n\n  const { parentElement, menu } = self;\n\n  const hasData = closest(target, dropdownSelector) !== null;\n  const isForm = parentElement && parentElement.contains(target)\n    && (target.tagName === 'form' || closest(target, 'form') !== null);\n\n  if (type === mouseclickEvent && isEmptyAnchor(target)) {\n    e.preventDefault();\n  }\n  if (type === focusEvent\n    && (target === element || target === menu || menu.contains(target))) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (isForm || hasData) ; else if (self) {\n    self.hide();\n  }\n}\n\n/**\n * Handles `click` event listener for `Dropdown`.\n * @this {HTMLElement}\n * @param {MouseEvent} e event object\n */\nfunction dropdownClickHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.toggle();\n    /* istanbul ignore else */\n    if (target && isEmptyAnchor(target)) e.preventDefault();\n  }\n}\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n * @param {KeyboardEvent} e event object\n */\nfunction dropdownPreventScroll(e) {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n}\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n * @param {KeyboardEvent} e keyboard key\n * @this {Document}\n */\nfunction dropdownKeyHandler(e) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = element && getDocument(element);\n  /* istanbul ignore next: impossible to satisfy */\n  if (!self || !activeElement) return;\n  const { menu, open } = self;\n  const menuItems = getMenuItems(menu);\n\n  // arrow up & down\n  if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n    let idx = menuItems.indexOf(activeElement);\n    /* istanbul ignore else */\n    if (activeElement === element) {\n      idx = 0;\n    } else if (code === keyArrowUp) {\n      idx = idx > 1 ? idx - 1 : 0;\n    } else if (code === keyArrowDown) {\n      idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n    }\n    /* istanbul ignore else */\n    if (menuItems[idx]) focus(menuItems[idx]);\n  }\n\n  if (keyEscape === code && open) {\n    self.toggle();\n    focus(element);\n  }\n}\n\n/**\n * @this {globalThis}\n * @returns {void}\n */\nfunction dropdownLayoutHandler() {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nclass Dropdown extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target Element or string selector\n   * @param {BSN.Options.Dropdown=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const { parentElement } = element;\n\n    // set targets\n    /** @type {(Element | HTMLElement)} */\n    self.parentElement = parentElement;\n    /** @type {(Element | HTMLElement)} */\n    self.menu = querySelector(`.${dropdownMenuClass}`, parentElement);\n\n    // set initial state to closed\n    /** @type {boolean} */\n    self.open = false;\n\n    // add event listener\n    toggleDropdownHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return dropdownComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return dropdownDefaults; }\n  /* eslint-enable */\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    const self = this;\n\n    if (self.open) self.hide();\n    else self.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (open) return;\n\n    const currentElement = getCurrentOpenDropdown(element);\n    const currentInstance = currentElement && getDropdownInstance(currentElement);\n    if (currentInstance) currentInstance.hide();\n\n    // dispatch event\n    [showDropdownEvent, shownDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, showDropdownEvent);\n    if (showDropdownEvent.defaultPrevented) return;\n\n    addClass(menu, showClass);\n    addClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'true');\n\n    // change menu position\n    styleDropdown(self);\n\n    self.open = !open;\n\n    focus(element); // focus the element\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, shownDropdownEvent);\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (!open) return;\n\n    [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, hideDropdownEvent);\n    if (hideDropdownEvent.defaultPrevented) return;\n\n    removeClass(menu, showClass);\n    removeClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'false');\n\n    self.open = !open;\n    // only re-attach handler if the instance is not disposed\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, hiddenDropdownEvent);\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    const self = this;\n    if (self.open) self.hide();\n\n    toggleDropdownHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Dropdown, {\n  selector: dropdownSelector,\n  init: dropdownInitCallback,\n  getInstance: getDropdownInstance,\n});\n\n/**\n * A global namespace for aria-hidden.\n * @type {string}\n */\nconst ariaHidden = 'aria-hidden';\n\n/**\n * A global namespace for aria-modal.\n * @type {string}\n */\nconst ariaModal = 'aria-modal';\n\n/**\n * Shortcut for `HTMLElement.removeAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {void}\n */\nconst removeAttribute = (element, attribute) => element.removeAttribute(attribute);\n\n/**\n * Returns the `document.body` or the `<body>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLBodyElement}\n */\nfunction getDocumentBody(node) {\n  return getDocument(node).body;\n}\n\n/** @type {string} */\nconst modalString = 'modal';\n\n/** @type {string} */\nconst modalComponent = 'Modal';\n\n/**\n * Check if target is a `ShadowRoot`.\n *\n * @param {any} element target\n * @returns {boolean} the query result\n */\nconst isShadowRoot = (element) => (element && element.constructor.name === 'ShadowRoot')\n  || false;\n\n/**\n * Returns the `parentNode` also going through `ShadowRoot`.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {Node} node the target node\n * @returns {Node} the apropriate parent node\n */\nfunction getParentNode(node) {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  return (\n    node.assignedSlot // step into the shadow DOM of the parent of a slotted node\n    || node.parentNode // DOM Element detected\n    || (isShadowRoot(node) && node.host) // ShadowRoot detected\n    || getDocumentElement(node) // fallback\n  );\n}\n\n/**\n * Check if a target element is a `<table>`, `<td>` or `<th>`.\n * This specific check is important for determining\n * the `offsetParent` of a given element.\n *\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isTableElement = (element) => (element && ['TABLE', 'TD', 'TH'].includes(element.tagName))\n  || false;\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * When `getOffset` is *true*, it returns the `offsetParent` for tooltip/popover\n * offsets computation similar to **floating-ui**.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element the target\n * @param {boolean=} getOffset when *true* it will return an `offsetParent`\n * @returns {ParentNode | Window} the query result\n */\nfunction getElementContainer(element, getOffset) {\n  const majorBlockTags = ['HTML', 'BODY'];\n\n  if (getOffset) {\n    /** @type {any} */\n    let { offsetParent } = element;\n    const win = getWindow(element);\n\n    while (offsetParent && (isTableElement(offsetParent)\n      || (isHTMLElement(offsetParent)\n        // we must count for both fixed & sticky\n        && !['sticky', 'fixed'].includes(getElementStyle(offsetParent, 'position'))))) {\n      offsetParent = offsetParent.offsetParent;\n    }\n\n    if (!offsetParent || (majorBlockTags.includes(offsetParent.tagName)\n        || getElementStyle(offsetParent, 'position') === 'static')) {\n      offsetParent = win;\n    }\n    return offsetParent;\n  }\n\n  /** @type {ParentNode[]} */\n  const containers = [];\n  /** @type {ParentNode} */\n  let { parentNode } = element;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode);\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || !!parentNode.shadowRoot\n      || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return containers.find((c, i) => {\n    if (getElementStyle(c, 'position') !== 'relative'\n      && containers.slice(i + 1).every((r) => getElementStyle(r, 'position') === 'static')) {\n      return c;\n    }\n    return null;\n  }) || getDocumentBody(element);\n}\n\n/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\n\n/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\n\n/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\n\n/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\n\n/** @param {(HTMLElement | Document)=} parent */\nconst getFixedItems = (parent) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n * @param {HTMLElement=} element the target modal/offcanvas\n */\nfunction resetScrollbar(element) {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n}\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n * @param {HTMLElement=} element\n * @returns {number} the value\n */\nfunction measureScrollbar(element) {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n}\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param {HTMLElement} element the target modal/offcanvas\n * @param {boolean=} overflow body does overflow or not\n */\nfunction setScrollbar(element, overflow) {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n}\n\n/**\n * This is a shortie for `document.createElement` method\n * which allows you to create a new `HTMLElement` for a given `tagName`\n * or based on an object with specific non-readonly attributes:\n * `id`, `className`, `textContent`, `style`, etc.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n *\n * @param {Record<string, string> | string} param `tagName` or object\n * @return {HTMLElement} a new `HTMLElement` or `Element`\n */\nfunction createElement(param) {\n  if (!param) return null;\n\n  if (typeof param === 'string') {\n    return getDocument().createElement(param);\n  }\n\n  const { tagName } = param;\n  const attr = { ...param };\n  const newElement = createElement(tagName);\n  delete attr.tagName;\n  ObjectAssign(newElement, attr);\n  return newElement;\n}\n\n/** @type {string} */\nconst offcanvasString = 'offcanvas';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div');\n\n/**\n * Returns the current active modal / offcancas element.\n * @param {HTMLElement=} element the context element\n * @returns {HTMLElement?} the requested element\n */\nfunction getCurrentOpen(element) {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n}\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n * @param {boolean=} isModal\n */\nfunction toggleOverlayType(isModal) {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n}\n\n/**\n * Append the overlay to DOM.\n * @param {HTMLElement} container\n * @param {boolean} hasFade\n * @param {boolean=} isModal\n */\nfunction appendOverlay(container, hasFade, isModal) {\n  toggleOverlayType(isModal);\n  container.append(overlay);\n  if (hasFade) addClass(overlay, fadeClass);\n}\n\n/**\n * Shows the overlay to the user.\n */\nfunction showOverlay() {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n}\n\n/**\n * Hides the overlay from the user.\n */\nfunction hideOverlay() {\n  removeClass(overlay, showClass);\n}\n\n/**\n * Removes the overlay from DOM.\n * @param {HTMLElement=} element\n */\nfunction removeOverlay(element) {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    overlay.remove();\n    resetScrollbar(element);\n  }\n}\n\n/**\n * @param {HTMLElement} element target\n * @returns {boolean}\n */\nfunction isVisible(element) {\n  return isHTMLElement(element)\n    && getElementStyle(element, 'visibility') !== 'hidden'\n    && element.offsetParent !== null;\n}\n\n/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true, // boolean|string\n  keyboard: true, // boolean\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Modal>}\n */\nconst getModalInstance = (element) => getInstance(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n * @type {BSN.InitCallback<Modal>}\n */\nconst modalInitCallback = (element) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = OriginalEvent(`show.bs.${modalString}`);\nconst shownModalEvent = OriginalEvent(`shown.bs.${modalString}`);\nconst hideModalEvent = OriginalEvent(`hide.bs.${modalString}`);\nconst hiddenModalEvent = OriginalEvent(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction setModalScrollbar(self) {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */'paddingLeft';\n    const padStyle = {};\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, (modalOverflow || clientHeight !== scrollHeight));\n}\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleModalDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getWindow(element), resizeEvent, self.update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleModalHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, modalClickHandler));\n  }\n}\n\n/**\n * Executes after a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function} callback the `Modal` instance\n */\nfunction afterModalHide(self, callback) {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement);\n\n  /* istanbul ignore else */\n  if (callback) callback();\n\n  hiddenModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, hiddenModalEvent);\n}\n\n/**\n * Executes after a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalShow(self) {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, shownModalEvent);\n}\n\n/**\n * Executes before a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction beforeModalShow(self) {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n}\n\n/**\n * Executes before a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function=} callback when `true` skip animation\n */\nfunction beforeModalHide(self, callback) {\n  const {\n    element, options, hasFade,\n  } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && !callback && hasFade && hasClass(overlay, showClass)\n    && !getCurrentOpen(element)) { // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self, callback);\n  }\n}\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.toggle();\n}\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction modalKeyHandler({ code, target }) {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  const { options } = self;\n  /* istanbul ignore else */\n  if (options.keyboard && code === keyEscape // the keyboard option is enabled and the key is 27\n    && hasClass(element, showClass)) { // the modal is not visible\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalDismissHandler(e) {\n  const element = this;\n  const self = getModalInstance(element);\n\n  // this timer is needed\n  /* istanbul ignore next: must have a filter */\n  if (!self || Timer.get(element)) return;\n\n  const { options, isStatic, modalDialog } = self;\n  const { backdrop } = options;\n  const { target } = e;\n\n  const selectedText = getDocument(element).getSelection().toString().length;\n  const targetInsideDialog = modalDialog.contains(target);\n  const dismiss = target && closest(target, modalDismissSelector);\n\n  /* istanbul ignore else */\n  if (isStatic && !targetInsideDialog) {\n    Timer.set(element, () => {\n      addClass(element, modalStaticClass);\n      emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n    }, 17);\n  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n    self.relatedTarget = dismiss || null;\n    self.hide();\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction staticTransitionEnd(self) {\n  const { element, modalDialog } = self;\n  const duration = getElementTransitionDuration(modalDialog) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n}\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nclass Modal extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually the `.modal` element\n   * @param {BSN.Options.Modal=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n\n    // the modal\n    const { element } = self;\n\n    // the modal-dialog\n    /** @type {(HTMLElement)} */\n    self.modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // modal can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional internals\n    /** @type {boolean} */\n    self.isStatic = self.options.backdrop === 'static';\n    /** @type {boolean} */\n    self.hasFade = hasClass(element, fadeClass);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n\n    // attach event listeners\n    toggleModalHandler(self, true);\n\n    // bind\n    self.update = self.update.bind(self);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return modalComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return modalDefaults; }\n  /* eslint-enable */\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, hasFade, relatedTarget, container,\n    } = self;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, showModalEvent);\n    if (showModalEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getModalInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Offcanvas');\n      that1.hide();\n    }\n\n    if (backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, hasFade, true);\n      } else {\n        toggleOverlayType(true);\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n\n      showOverlay();\n      setTimeout(() => beforeModalShow(self), overlayDelay);\n    } else {\n      beforeModalShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hide the modal from the user.\n   * @param {Function=} callback when defined it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const {\n      element, hasFade, relatedTarget,\n    } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, hideModalEvent);\n    if (hideModalEvent.defaultPrevented) return;\n    removeClass(element, showClass);\n    setAttribute(element, ariaHidden, 'true');\n    removeAttribute(element, ariaModal);\n\n    // if (hasFade && callback) {\n    /* istanbul ignore else */\n    if (hasFade) {\n      emulateTransitionEnd(element, () => beforeModalHide(self, callback));\n    } else {\n      beforeModalHide(self, callback);\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   * @this {Modal} the modal instance\n   */\n  update() {\n    const self = this;\n    /* istanbul ignore else */\n    if (hasClass(self.element, showClass)) setModalScrollbar(self);\n  }\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const self = this;\n    toggleModalHandler(self);\n    // use callback\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Modal, {\n  selector: modalSelector,\n  init: modalInitCallback,\n  getInstance: getModalInstance,\n});\n\n/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\n\n/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Offcanvas>}\n */\nconst getOffcanvasInstance = (element) => getInstance(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n * @type {BSN.InitCallback<Offcanvas>}\n */\nconst offcanvasInitCallback = (element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = OriginalEvent(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = OriginalEvent(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = OriginalEvent(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = OriginalEvent(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction setOffCanvasScrollbar(self) {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n}\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true*, listeners are added\n */\nfunction toggleOffcanvasEvents(self, add) {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach((btn) => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n}\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true* listeners are added\n */\nfunction toggleOffCanvasDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n}\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasShow(self) {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n}\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function=} callback the hide callback\n */\nfunction beforeOffcanvasHide(self, callback) {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self, callback));\n  } else hideOffcanvasComplete(self, callback);\n}\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasTriggerHandler(e) {\n  const trigger = closest(this, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasDismissHandler(e) {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element);\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must have a filter */\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (overlay.contains(target) && backdrop === 'static') return;\n\n  /* istanbul ignore else */\n  if (!(selection && selection.toString().length)\n    && ((!element.contains(target) && backdrop\n    && /* istanbul ignore next */(!trigger || triggers.includes(target)))\n    || (offCanvasDismiss && offCanvasDismiss.contains(target)))) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss : null;\n    self.hide();\n  }\n\n  /* istanbul ignore next */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction offcanvasKeyDismissHandler({ code, target }) {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n\n  /* istanbul ignore else */\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction showOffcanvasComplete(self) {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n}\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function} callback the hide callback\n */\nfunction hideOffcanvasComplete(self, callback) {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find((x) => isVisible(x));\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n  // callback\n  if (callback) callback();\n}\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nclass Offcanvas extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually an `.offcanvas` element\n   * @param {BSN.Options.Offcanvas=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    const self = this;\n\n    // instance element\n    const { element } = self;\n\n    // all the triggering buttons\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional instance property\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return offcanvasComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return offcanvasDefaults; }\n  /* eslint-enable */\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, container, relatedTarget,\n    } = self;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget;\n    shownOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getOffcanvasInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Modal');\n      that1.hide();\n    }\n\n    if (options.backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);\n    } else {\n      beforeOffcanvasShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   * @param {Function=} callback when `true` it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const { element, relatedTarget } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!callback) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(self, callback));\n    } else beforeOffcanvasHide(self, callback);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const self = this;\n    toggleOffcanvasEvents(self);\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Offcanvas, {\n  selector: offcanvasSelector,\n  init: offcanvasInitCallback,\n  getInstance: getOffcanvasInstance,\n});\n\n/** @type {string} */\nconst popoverString = 'popover';\n\n/** @type {string} */\nconst popoverComponent = 'Popover';\n\n/** @type {string} */\nconst tooltipString = 'tooltip';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param {string} tipType the expected markup type\n * @returns {string} the template markup\n */\nfunction getTipTemplate(tipType) {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n}\n\n/**\n * Checks if an element is an `<svg>` (or any type of SVG element),\n * `<img>` or `<video>`.\n *\n * *Tooltip* / *Popover* works different with media elements.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\n\nconst isMedia = (element) => (\n  element\n  && element.nodeType === 1\n  && ['SVG', 'Image', 'Video'].some((s) => element.constructor.name.includes(s))) || false;\n\n/**\n * Returns an `{x,y}` object with the target\n * `HTMLElement` / `Node` scroll position.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Window} element target node / element\n * @returns {{x: number, y: number}} the scroll tuple\n */\nfunction getNodeScroll(element) {\n  const isWin = 'scrollX' in element;\n  const x = isWin ? element.scrollX : element.scrollLeft;\n  const y = isWin ? element.scrollY : element.scrollTop;\n\n  return { x, y };\n}\n\n/**\n * Checks if a target `HTMLElement` is affected by scale.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @returns {boolean} the query result\n */\nfunction isScaledElement(element) {\n  if (!element || !isHTMLElement(element)) return false;\n  const { width, height } = getBoundingClientRect(element);\n  const { offsetWidth, offsetHeight } = element;\n  return Math.round(width) !== offsetWidth\n    || Math.round(height) !== offsetHeight;\n}\n\n/**\n * Returns the rect relative to an offset parent.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @param {ParentNode | Window} offsetParent the container / offset parent\n * @param {{x: number, y: number}} scroll the offsetParent scroll position\n * @returns {SHORTY.OffsetRect}\n */\nfunction getRectRelativeToOffsetParent(element, offsetParent, scroll) {\n  const isParentAnElement = isHTMLElement(offsetParent);\n  const rect = getBoundingClientRect(element, isParentAnElement && isScaledElement(offsetParent));\n  const offsets = { x: 0, y: 0 };\n\n  /* istanbul ignore next */\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, true);\n    offsets.x = offsetRect.x + offsetParent.clientLeft;\n    offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/** @type {Record<string, string>} */\nconst tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\n/**\n * Style popovers and tooltips.\n * @param {BSN.Tooltip | BSN.Popover} self the `Popover` / `Tooltip` instance\n * @param {PointerEvent=} e event object\n */\nfunction styleTip(self, e) {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const {\n    element, tooltip, options, arrow, offsetParent,\n  } = self;\n  const tipPositions = { ...tipClassPositions };\n\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, {\n    // top: '0px', left: '0px', right: '', bottom: '',\n    top: '', left: '', right: '', bottom: '',\n  });\n  const isPopover = self.name === popoverComponent;\n  const {\n    offsetWidth: tipWidth, offsetHeight: tipHeight,\n  } = tooltip;\n  const {\n    clientWidth: htmlcw, clientHeight: htmlch,\n  } = getDocumentElement(element);\n  const { container } = options;\n  let { placement } = options;\n  const {\n    left: parentLeft, right: parentRight, top: parentTop,\n  } = getBoundingClientRect(container, true);\n  const {\n    clientWidth: parentCWidth, offsetWidth: parentOWidth,\n  } = container;\n  const scrollbarWidth = Math.abs(parentCWidth - parentOWidth);\n  // const tipAbsolute = getElementStyle(tooltip, 'position') === 'absolute';\n  const parentPosition = getElementStyle(container, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  const stickyParent = parentPosition === 'sticky';\n  const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(container, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent ? parentCWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentCWidth + parentLeft + (htmlcw - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n\n  const scroll = getNodeScroll(offsetParent);\n  const { x, y } = getRectRelativeToOffsetParent(element, offsetParent, scroll);\n  // reset arrow style\n  setElementStyle(arrow, {\n    top: '', left: '', right: '', bottom: '',\n  });\n  let topPosition;\n  let leftPosition;\n  let rightPosition;\n  let arrowTop;\n  let arrowLeft;\n  let arrowRight;\n\n  const arrowWidth = arrow.offsetWidth || 0;\n  const arrowHeight = arrow.offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight\n    + arrowHeight >= htmlch;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth\n    + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n    : bottomExceed;\n  leftExceed = vertical.includes(placement)\n    ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n    : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // first remove side positions if both left and right limits are exceeded\n  // we usually fall back to top|bottom\n  placement = (horizontal.includes(placement)) && leftExceed && rightExceed ? 'top' : placement;\n  // second, recompute placement\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  /* istanbul ignore else */\n  if (horizontal.includes(placement)) { // secondary|side positions\n    if (placement === 'left') { // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else { // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else { // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n      // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  /* istanbul ignore else */\n  if (isHTMLElement(arrow)) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n}\n\nconst tooltipDefaults = {\n  /** @type {string} */\n  template: getTipTemplate(tooltipString),\n  /** @type {string?} */\n  title: null, // string\n  /** @type {string?} */\n  customClass: null, // string | null\n  /** @type {string} */\n  trigger: 'hover focus',\n  /** @type {string?} */\n  placement: 'top', // string\n  /** @type {((c:string)=>string)?} */\n  sanitizeFn: null, // function\n  /** @type {boolean} */\n  animation: true, // bool\n  /** @type {number} */\n  delay: 200, // number\n  /** @type {HTMLElement?} */\n  container: null,\n};\n\n/**\n * A global namespace for aria-describedby.\n * @type {string}\n */\nconst ariaDescribedBy = 'aria-describedby';\n\n/**\n * A global namespace for `mousedown` event.\n * @type {string}\n */\nconst mousedownEvent = 'mousedown';\n\n/**\n * A global namespace for `mousemove` event.\n * @type {string}\n */\nconst mousemoveEvent = 'mousemove';\n\n/**\n * A global namespace for `focusin` event.\n * @type {string}\n */\nconst focusinEvent = 'focusin';\n\n/**\n * A global namespace for `focusout` event.\n * @type {string}\n */\nconst focusoutEvent = 'focusout';\n\n/**\n * A global namespace for `hover` event.\n * @type {string}\n */\nconst mousehoverEvent = 'hover';\n\n/**\n * A global namespace for `touchstart` event.\n * @type {string}\n */\nconst touchstartEvent = 'touchstart';\n\nlet elementUID = 0;\nlet elementMapUID = 0;\nconst elementIDMap = new Map();\n\n/**\n * Returns a unique identifier for popover, tooltip, scrollspy.\n *\n * @param {HTMLElement} element target element\n * @param {string=} key predefined key\n * @returns {number} an existing or new unique ID\n */\nfunction getUID(element, key) {\n  let result = key ? elementUID : elementMapUID;\n\n  if (key) {\n    const elID = getUID(element);\n    const elMap = elementIDMap.get(elID) || new Map();\n    if (!elementIDMap.has(elID)) {\n      elementIDMap.set(elID, elMap);\n    }\n    if (!elMap.has(key)) {\n      elMap.set(key, result);\n      elementUID += 1;\n    } else result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n\n    if (!elementIDMap.has(elkey)) {\n      elementIDMap.set(elkey, result);\n      elementMapUID += 1;\n    } else result = elementIDMap.get(elkey);\n  }\n  return result;\n}\n\n/**\n * Checks if an object is a `Function`.\n *\n * @param {any} fn the target object\n * @returns {boolean} the query result\n */\nconst isFunction = (fn) => (fn && fn.constructor.name === 'Function') || false;\n\nconst { userAgentData: uaDATA } = navigator;\n\n/**\n * A global namespace for `userAgentData` object.\n */\nconst userAgentData = uaDATA;\n\nconst { userAgent: userAgentString } = navigator;\n\n/**\n * A global namespace for `navigator.userAgent` string.\n */\nconst userAgent = userAgentString;\n\nconst appleBrands = /(iPhone|iPod|iPad)/;\n\n/**\n * A global `boolean` for Apple browsers.\n * @type {boolean}\n */\nconst isApple = userAgentData ? userAgentData.brands.some((x) => appleBrands.test(x.brand))\n  : /* istanbul ignore next */appleBrands.test(userAgent);\n\n/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\n\n/** @type {string} */\nconst tooltipComponent = 'Tooltip';\n\n/**\n * Checks if an object is a `NodeList`.\n * => equivalent to `object instanceof NodeList`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isNodeList = (object) => (object && object.constructor.name === 'NodeList') || false;\n\n/**\n * Shortcut for `typeof SOMETHING === \"string\"`.\n *\n * @param  {any} str input value\n * @returns {boolean} the query result\n */\nconst isString = (str) => typeof str === 'string';\n\n/**\n * Shortcut for `Array.isArray()` static method.\n *\n * @param  {any} arr array-like iterable object\n * @returns {boolean} the query result\n */\nconst isArray = (arr) => Array.isArray(arr);\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param {HTMLElement} element target\n * @param {Node | string} content the `Element` to append / string\n * @param {ReturnType<any>} sanitizeFn a function to sanitize string content\n */\nfunction setHtml(element, content, sanitizeFn) {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element) || (isString(content) && !content.length)) return;\n\n  /* istanbul ignore else */\n  if (isString(content)) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const win = getWindow(element);\n    const domParser = new win.DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content)\n    || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n}\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param {BSN.Popover | BSN.Tooltip} self the `Tooltip` / `Popover` instance\n */\nfunction createTip(self) {\n  const { id, element, options } = self;\n  const {\n    animation, customClass, sanitizeFn, placement, dismissible,\n    title, content, template, btnClose,\n  } = options;\n  const isTooltip = self.name === tooltipComponent;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts = [];\n  let contentParts = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  /** @type {HTMLElement?} */\n  let tooltipTemplate;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div');\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate) && tooltipTemplate.cloneNode(true);\n\n  const { tooltip } = self;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip);\n  const { arrow } = self;\n\n  if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n  else {\n    const tempTitle = createElement('div');\n    setHtml(tempTitle, title, sanitizeFn);\n    titleParts = [...[...tempTitle.childNodes]];\n  }\n\n  if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n  else {\n    const tempContent = createElement('div');\n    setHtml(tempContent, content, sanitizeFn);\n    contentParts = [...[...tempContent.childNodes]];\n  }\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        titleParts = [...titleParts, tempBtn.firstChild];\n      }\n    } else {\n      /* istanbul ignore else */\n      if (tooltipHeader) tooltipHeader.remove();\n      if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        contentParts = [...contentParts, tempBtn.firstChild];\n      }\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  /* istanbul ignore else */\n  if (!isTooltip) {\n    /* istanbul ignore else */\n    if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n    /* istanbul ignore else */\n    if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n    // set btn\n    self.btn = querySelector('.btn-close', tooltip);\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // Bootstrap 5.2.x\n  addClass(tooltip, 'position-absolute');\n  addClass(arrow, 'position-absolute');\n\n  // set popover animation and placement\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  /* istanbul ignore else */\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  /* istanbul ignore else */\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n}\n\n/**\n * @param {HTMLElement} tip target\n * @param {ParentNode} container parent container\n * @returns {boolean}\n */\nfunction isVisibleTip(tip, container) {\n  return isHTMLElement(tip) && container.contains(tip);\n}\n\n/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tooltip>}\n */\nlet getTooltipInstance = (element) => getInstance(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n * @type {BSN.InitCallback<Tooltip>}\n */\nconst tooltipInitCallback = (element) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction removeTooltip(self) {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  tooltip.remove();\n}\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the parent dispose callback\n */\nfunction disposeTooltipComplete(self, callback) {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n}\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipAction(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n}\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipShownAction(self) {\n  const { element } = self;\n  const shownTooltipEvent = OriginalEvent(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n}\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the dispose callback\n */\nfunction tooltipHiddenAction(self, callback) {\n  const { element } = self;\n  const hiddenTooltipEvent = OriginalEvent(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  if (isFunction(callback)) callback();\n  Timer.clear(element, 'out');\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger, dismissible } = options;\n\n  if (trigger.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  /** @type {string[]} */\n  const triggerOptions = trigger.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions.forEach((tr) => {\n    /* istanbul ignore else */\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, (!dismissible ? self.toggle : self.show));\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      /* istanbul ignore else */\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      /* istanbul ignore else */\n      if (isApple) {\n        action(element, mouseclickEvent, () => focus(element));\n      }\n    }\n  });\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipOpenHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, options, offsetParent } = self;\n  const { container } = options;\n  const { offsetHeight, scrollHeight } = container;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    const overflow = offsetHeight !== scrollHeight;\n    const scrollTarget = overflow || offsetParent !== win ? container : win;\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(scrollTarget, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n}\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {string=} content when `true`, event listeners are added\n */\nfunction toggleTooltipTitle(self, content) {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1],\n    (content || getAttribute(element, titleAtt[0])));\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n}\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nclass Tooltip extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Tooltip=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n    const { element } = self;\n    const isTooltip = self.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = (elem) => getInstance(elem, tipComponent);\n\n    // additional properties\n    /** @type {any} */\n    self.tooltip = {};\n    if (!isTooltip) {\n      /** @type {any?} */\n      self.btn = null;\n    }\n    /** @type {any} */\n    self.arrow = {};\n    /** @type {any} */\n    self.offsetParent = {};\n    /** @type {boolean} */\n    self.enabled = true;\n    /** @type {string} Set unique ID for `aria-describedby`. */\n    self.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = self;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) {\n      // throw Error(`${this.name} Error: target has no content set.`);\n      return;\n    }\n\n    const container = querySelector(options.container, getDocument(element));\n    const idealContainer = getElementContainer(element);\n\n    // bypass container option when its position is static/relative\n    self.options.container = !container || (container\n      && ['static', 'relative'].includes(getElementStyle(container, 'position')))\n      ? idealContainer\n      : /* istanbul ignore next */container || getDocumentBody(element);\n\n    // reset default options\n    tooltipDefaults[titleAttr] = null;\n\n    // all functions bind\n    self.handleTouch = self.handleTouch.bind(self);\n    self.update = self.update.bind(self);\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n    self.toggle = self.toggle.bind(self);\n\n    // set title attributes and add event listeners\n    /* istanbul ignore else */\n    if (hasAttribute(element, titleAttr) && isTooltip) {\n      toggleTooltipTitle(self, options.title);\n    }\n\n    // create tooltip here\n    createTip(self);\n\n    // attach events\n    toggleTooltipHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return tooltipComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return tooltipDefaults; }\n  /* eslint-enable */\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip}\n   */\n  show(e) {\n    const self = this;\n    const {\n      options, tooltip, element, id,\n    } = self;\n    const { container, animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const showTooltipEvent = OriginalEvent(`show.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, showTooltipEvent);\n        if (showTooltipEvent.defaultPrevented) return;\n\n        // append to container\n        container.append(tooltip);\n        setAttribute(element, ariaDescribedBy, `#${id}`);\n        // set offsetParent\n        self.offsetParent = getElementContainer(tooltip, true);\n\n        self.update(e);\n        toggleTooltipOpenHandlers(self, true);\n\n        /* istanbul ignore else */\n        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));\n        else tooltipShownAction(self);\n      }, 17, 'in');\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @this {Tooltip} the Tooltip instance\n   * @param {Function=} callback the dispose callback\n   */\n  hide(callback) {\n    const self = this;\n    const { options, tooltip, element } = self;\n    const { container, animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const hideTooltipEvent = OriginalEvent(`hide.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, hideTooltipEvent);\n\n        if (hideTooltipEvent.defaultPrevented) return;\n\n        removeClass(tooltip, showClass);\n        toggleTooltipOpenHandlers(self);\n\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self, callback));\n        else tooltipHiddenAction(self, callback);\n      }, delay + 17, 'out');\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the `Tooltip` instance\n   */\n  update(e) {\n    styleTip(this, e);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the instance\n   */\n  toggle(e) {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (!isVisibleTip(tooltip, options.container)) self.show(e);\n    else self.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const self = this;\n    const { enabled } = self;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(self, true);\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const self = this;\n    const {\n      tooltip, options, enabled,\n    } = self;\n    const { animation, container } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (isVisibleTip(tooltip, container) && animation) {\n        self.hide(() => toggleTooltipHandlers(self));\n      } else {\n        toggleTooltipHandlers(self);\n      }\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    const self = this;\n    if (!self.enabled) self.enable();\n    else self.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }) {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore next */\n    if (tooltip.contains(target) || target === element\n      || (target && element.contains(target))) ; else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const self = this;\n    const { tooltip, options } = self;\n    const callback = () => disposeTooltipComplete(self, () => super.dispose());\n\n    if (options.animation && isVisibleTip(tooltip, options.container)) {\n      self.options.delay = 0; // reset delay\n      self.hide(callback);\n    } else {\n      callback();\n    }\n  }\n}\n\nObjectAssign(Tooltip, {\n  selector: tooltipSelector,\n  init: tooltipInitCallback,\n  getInstance: getTooltipInstance,\n  styleTip,\n});\n\n/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults = {\n  ...tooltipDefaults,\n  /** @type {string} */\n  template: getTipTemplate(popoverString),\n  /** @type {string} */\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n  /** @type {boolean} */\n  dismissible: false,\n  /** @type {string?} */\n  content: null,\n};\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nclass Popover extends Tooltip {\n  /* eslint-disable -- we want to specify Popover Options */\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Popover=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */ \n  get name() { return popoverComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return popoverDefaults; }\n  /* eslint-enable */\n\n  /* extend original `show()` */\n  show() {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  }\n}\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Popover>}\n */\nconst getPopoverInstance = (element) => getInstance(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n * @type {BSN.InitCallback<Popover>}\n */\nconst popoverInitCallback = (element) => new Popover(element);\n\nObjectAssign(Popover, {\n  selector: popoverSelector,\n  init: popoverInitCallback,\n  getInstance: getPopoverInstance,\n  styleTip,\n});\n\n/**\n * Shortcut for `HTMLElement.getElementsByTagName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByTagName`.\n *\n * @param {string} selector the tag name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByTagName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByTagName(selector);\n}\n\n/** @type {string} */\nconst scrollspyString = 'scrollspy';\n\n/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\n\n/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<ScrollSpy>}\n */\nconst getScrollSpyInstance = (element) => getInstance(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n * @type {BSN.InitCallback<ScrollSpy>}\n */\nconst scrollspyInitCallback = (element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = OriginalEvent(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n */\nfunction updateSpyTargets(self) {\n  const {\n    target, scrollTarget, options, itemsLength, scrollHeight, element,\n  } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget && getScrollHeight(scrollTarget);\n\n  self.scrollTop = isWin ? scrollTarget.scrollY : scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (itemsLength !== links.length || scrollHEIGHT !== scrollHeight)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach((link) => {\n      href = getAttribute(link, 'href');\n      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#'\n        && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n}\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n * @param {Node | Window} scrollTarget the `ScrollSpy` instance\n * @return {number} `scrollTarget` height\n */\nfunction getScrollHeight(scrollTarget) {\n  return isHTMLElement(scrollTarget)\n    ? scrollTarget.scrollHeight\n    : getDocumentElement(scrollTarget).scrollHeight;\n}\n\n/**\n * Returns the height property of the scrolling element.\n * @param {ScrollSpy} params the `ScrollSpy` instance\n * @returns {number}\n */\nfunction getOffsetHeight({ element, scrollTarget }) {\n  return (isWindow(scrollTarget))\n    ? scrollTarget.innerHeight\n    : getBoundingClientRect(element).height;\n}\n\n/**\n * Clear all items of the target.\n * @param {HTMLElement} target a single item\n */\nfunction clear(target) {\n  [...getElementsByTagName('A', target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n}\n\n/**\n * Activates a new item.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {HTMLElement} item a single item\n */\nfunction activate(self, item) {\n  const { target, element } = self;\n  clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach((menuItem) => {\n    /** @type {HTMLElement?} */\n    const parentLink = menuItem.previousElementSibling;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n}\n\n/**\n * Toggles on/off the component event listener.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {boolean=} add when `true`, listener is added\n */\nfunction toggleSpyHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.scrollTarget, scrollEvent, self.refresh, passiveHandler);\n}\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nclass ScrollSpy extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.ScrollSpy=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element & options\n    const { element, options } = self;\n\n    // additional properties\n    /** @type {HTMLElement?} */\n    self.target = querySelector(options.target, getDocument(element));\n\n    // invalidate\n    if (!self.target) return;\n\n    // set initial state\n    /** @type {HTMLElement | Window} */\n    self.scrollTarget = element.clientHeight < element.scrollHeight\n      ? element : getWindow(element);\n    /** @type {number} */\n    self.scrollTop = 0;\n    /** @type {number} */\n    self.maxScroll = 0;\n    /** @type {number} */\n    self.scrollHeight = 0;\n    /** @type {HTMLElement?} */\n    self.activeItem = null;\n    /** @type {HTMLElement[]} */\n    self.items = [];\n    /** @type {number} */\n    self.itemsLength = 0;\n    /** @type {number[]} */\n    self.offsets = [];\n\n    // bind events\n    self.refresh = self.refresh.bind(self);\n\n    // add event handlers\n    toggleSpyHandlers(self, true);\n\n    self.refresh();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return scrollspyComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return scrollspyDefaults; }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh() {\n    const self = this;\n    const { target } = self;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore next */\n    if (target.offsetHeight === 0) return;\n\n    updateSpyTargets(self);\n\n    const {\n      scrollTop, maxScroll, itemsLength, items, activeItem,\n    } = self;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      /* istanbul ignore else */\n      if (activeItem !== newActiveItem) {\n        activate(self, newActiveItem);\n      }\n      return;\n    }\n\n    const { offsets } = self;\n\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      self.activeItem = null;\n      clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (activeItem !== item && scrollTop >= offsets[i]\n        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {\n        activate(self, item);\n      }\n    });\n  }\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(ScrollSpy, {\n  selector: scrollspySelector,\n  init: scrollspyInitCallback,\n  getInstance: getScrollSpyInstance,\n});\n\n/**\n * A global namespace for aria-selected.\n * @type {string}\n */\nconst ariaSelected = 'aria-selected';\n\n/** @type {string} */\nconst tabString = 'tab';\n\n/** @type {string} */\nconst tabComponent = 'Tab';\n\n/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tab>}\n */\nconst getTabInstance = (element) => getInstance(element, tabComponent);\n\n/**\n * A `Tab` initialization callback.\n * @type {BSN.InitCallback<Tab>}\n */\nconst tabInitCallback = (element) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = OriginalEvent(`show.bs.${tabString}`);\nconst shownTabEvent = OriginalEvent(`shown.bs.${tabString}`);\nconst hideTabEvent = OriginalEvent(`hide.bs.${tabString}`);\nconst hiddenTabEvent = OriginalEvent(`hidden.bs.${tabString}`);\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n * @type {Map<HTMLElement, any>}\n */\nconst tabPrivate = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabEnd(self) {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n}\n\n/**\n * Executes before showing the tab content.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabShow(self) {\n  const {\n    element, tabContent, content: nextContent, nav,\n  } = self;\n  const { tab } = nav && tabPrivate.get(nav);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element);\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab;\n  dispatchEvent(element, shownTabEvent);\n}\n\n/**\n * Executes before hiding the tab.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabHide(self) {\n  const {\n    element, content: nextContent, tabContent, nav,\n  } = self;\n  const { tab, content } = nav && tabPrivate.get(nav);\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      addClass(c, 'overflow-hidden');\n    });\n    currentHeight = content.scrollHeight || /* istanbul ignore next */0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n  if (showTabEvent.defaultPrevented) return;\n\n  addClass(nextContent, activeClass);\n  removeClass(content, activeClass);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const nextHeight = nextContent.scrollHeight;\n    tabPrivate.set(element, { currentHeight, nextHeight });\n\n    addClass(tabContent, collapsingClass);\n    tabContent.style.height = `${currentHeight}px`;\n    reflow(tabContent);\n    [content, nextContent].forEach((c) => {\n      removeClass(c, 'overflow-hidden');\n    });\n  }\n\n  if (nextContent && hasClass(nextContent, fadeClass)) {\n    setTimeout(() => {\n      addClass(nextContent, showClass);\n      emulateTransitionEnd(nextContent, () => {\n        triggerTabShow(self);\n      });\n    }, 1);\n  } else {\n    addClass(nextContent, showClass);\n    triggerTabShow(self);\n  }\n\n  dispatchEvent(tab, hiddenTabEvent);\n}\n\n/**\n * Returns the current active tab and its target content.\n * @param {Tab} self the `Tab` instance\n * @returns {Record<string, any>} the query result\n */\nfunction getActiveTab(self) {\n  const { nav } = self;\n\n  const activeTabs = getElementsByClassName(activeClass, nav);\n  /** @type {(HTMLElement)=} */\n  let tab;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1\n    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = tab ? getTargetElement(tab) : null;\n  return { tab, content };\n}\n\n/**\n * Returns a parent dropdown.\n * @param {HTMLElement} element the `Tab` element\n * @returns {HTMLElement?} the parent dropdown\n */\nfunction getParentDropdown(element) {\n  const dropdown = closest(element, `.${dropdownMenuClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownMenuClasses[0]}-toggle`, dropdown) : null;\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Tab} self the `Tab` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleTabHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n}\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction tabClickHandler(e) {\n  const self = getTabInstance(this);\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n  e.preventDefault();\n\n  self.show();\n}\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nclass Tab extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    if (!content) return;\n\n    const nav = closest(element, '.nav');\n    const container = closest(content, '.tab-content');\n\n    /** @type {HTMLElement?} */\n    self.nav = nav;\n    /** @type {HTMLElement} */\n    self.content = content;\n    /** @type {HTMLElement?} */\n    self.tabContent = container;\n\n    // event targets\n    /** @type {HTMLElement?} */\n    self.dropdown = getParentDropdown(element);\n\n    // show first Tab instance of none is shown\n    // suggested on #432\n    const { tab } = getActiveTab(self);\n    if (nav && !tab) {\n      const firstTab = querySelector(tabSelector, nav);\n      const firstTabContent = firstTab && getTargetElement(firstTab);\n\n      /* istanbul ignore else */\n      if (firstTabContent) {\n        addClass(firstTab, activeClass);\n        addClass(firstTabContent, showClass);\n        addClass(firstTabContent, activeClass);\n        setAttribute(element, ariaSelected, 'true');\n      }\n    }\n\n    // add event listener\n    toggleTabHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return tabComponent; }\n  /* eslint-enable */\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const self = this;\n    const {\n      element, content: nextContent, nav, dropdown,\n    } = self;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(self);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      dispatchEvent(tab, hideTabEvent);\n      if (hideTabEvent.defaultPrevented) return;\n\n      addClass(element, activeClass);\n      setAttribute(element, ariaSelected, 'true');\n\n      const activeDropdown = getParentDropdown(tab);\n      if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n        removeClass(activeDropdown, activeClass);\n      }\n\n      /* istanbul ignore else */\n      if (nav) {\n        const toggleTab = () => {\n          removeClass(tab, activeClass);\n          setAttribute(tab, ariaSelected, 'false');\n          if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n        };\n\n        if (hasClass(content, fadeClass) || hasClass(nextContent, fadeClass)) {\n          Timer.set(nav, toggleTab, 1);\n        } else toggleTab();\n      }\n\n      removeClass(content, showClass);\n      if (hasClass(content, fadeClass)) {\n        emulateTransitionEnd(content, () => triggerTabHide(self));\n      } else {\n        triggerTabHide(self);\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Tab, {\n  selector: tabSelector,\n  init: tabInitCallback,\n  getInstance: getTabInstance,\n});\n\n/** @type {string} */\nconst toastString = 'toast';\n\n/** @type {string} */\nconst toastComponent = 'Toast';\n\n/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Toast>}\n */\nconst getToastInstance = (element) => getInstance(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n * @type {BSN.InitCallback<Toast>}\n */\nconst toastInitCallback = (element) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = OriginalEvent(`show.bs.${toastString}`);\nconst shownToastEvent = OriginalEvent(`shown.bs.${toastString}`);\nconst hideToastEvent = OriginalEvent(`hide.bs.${toastString}`);\nconst hiddenToastEvent = OriginalEvent(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToastComplete(self) {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n}\n\n/**\n * Executes after the toast is hidden to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToastComplete(self) {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n}\n\n/**\n * Executes before hiding the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToast(self) {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n}\n\n/**\n * Executes before showing the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToast(self) {\n  const { element, options } = self;\n  Timer.set(element, () => {\n    removeClass(element, hideClass); // B/C\n    reflow(element);\n    addClass(element, showClass);\n    addClass(element, showingClass);\n\n    if (options.animation) {\n      emulateTransitionEnd(element, () => showToastComplete(self));\n    } else {\n      showToastComplete(self);\n    }\n  }, 17, showingClass);\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Toast} self the `Toast` instance\n * @param {boolean=} add when `true`, it will add the listener\n */\nfunction toggleToastHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const {\n    element, triggers, dismiss, options,\n  } = self;\n\n  /* istanbul ignore else */\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, self.hide);\n  }\n\n  /* istanbul ignore else */\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent]\n      .forEach((e) => action(element, e, interactiveToastHandler));\n  }\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, toastClickHandler));\n  }\n}\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n * @param {Toast} self the `Toast` instance\n */\nfunction completeDisposeToast(self) {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n}\n\n/**\n * Handles the `click` event listener for toast.\n * @param {MouseEvent} e the `Event` object\n */\nfunction toastClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.show();\n}\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Toast` instance\n */\nfunction interactiveToastHandler(e) {\n  const element = this;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore next: a solid filter is required */\n  if (!self || (element === relatedTarget || element.contains(relatedTarget))) return;\n\n  if ([mouseenterEvent, focusinEvent].includes(type)) {\n    Timer.clear(element, toastString);\n  } else {\n    Timer.set(element, () => self.hide(), self.options.delay, toastString);\n  }\n}\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nclass Toast extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target `.toast` element\n   * @param {BSN.Options.Toast=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    const { element, options } = self;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    /** @type {HTMLElement?} */\n    self.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // bind\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n\n    // add event listener\n    toggleToastHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return toastComponent; }\n  /**\n   * Returns component default options.\n   */  \n  get defaults() { return toastDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() { return hasClass(this.element, showClass); }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (showToastEvent.defaultPrevented) return;\n\n      showToast(self);\n    }\n  }\n\n  /** Hides the toast. */\n  hide() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (hideToastEvent.defaultPrevented) return;\n      hideToast(self);\n    }\n  }\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Toast, {\n  selector: toastSelector,\n  init: toastInitCallback,\n  getInstance: getToastInstance,\n});\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {HTMLElement} target\n * @param {string} selector\n * @returns {boolean}\n */\nfunction matches(target, selector) {\n  return target.matches(selector);\n}\n\n/** @type {Record<string, any>} */\nconst componentsList = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n};\n\n/**\n * Initialize all matched `Element`s for one component.\n * @param {BSN.InitCallback<any>} callback\n * @param {NodeList | Node[]} collection\n */\nfunction initComponentDataAPI(callback, collection) {\n  [...collection].forEach((x) => callback(x));\n}\n\n/**\n * Remove one component from a target container element or all in the page.\n * @param {string} component the component name\n * @param {ParentNode} context parent `Node`\n */\nfunction removeComponentDataAPI(component, context) {\n  const compData = Data.getAllFor(component);\n\n  if (compData) {\n    [...compData].forEach((x) => {\n      const [element, instance] = x;\n      if (context.contains(element)) instance.dispose();\n    });\n  }\n}\n\n/**\n * Initialize all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction initCallback(context) {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    const { init, selector } = componentsList[comp];\n    initComponentDataAPI(init, elemCollection.filter((item) => matches(item, selector)));\n  });\n}\n\n/**\n * Remove all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction removeDataAPI(context) {\n  const lookUp = context && context.nodeName ? context : document;\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    removeComponentDataAPI(comp, lookUp);\n  });\n}\n\n// bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n\nconst BSN = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n\n  initCallback,\n  removeDataAPI,\n  Version,\n  EventListener: Listener,\n};\n\nexport { BSN as default };\n","import './css/common.css';\n\nimport BSN from 'bootstrap.native';\n\nconst modal = new BSN.Modal('#exampleModal');\nconsole.log(modal);\n\n\n\nconst PROMPT_DELAY = 3000;\n\nsetTimeout(() => {\n    modal.show();\n}, PROMPT_DELAY)"]}